[reftext="Pattern Matching"]
=== パターンマッチ

Scala has native pattern matching, one of the advantages over __plain__ Java. The basic syntax is close to Java's switch:

Scala は言語としてパターンマッチングに対応しているところが、__素の__ Java に対する利点の1つになっています。
基本的な構文は Java の switch 文によく似ています。

[source,java]
----
val s = i match {  
  case 1 => "one"
  case 2 => "two"
  case _ => "?"
}
----

Notably __match__ is an expression, it yields a result. Furthermore it offers

*   named parameters ``case i: Int => "Int " + i``
*   object deconstruction ``case Some(i) => i``
*   guards ``case Some(i) if i > 0 => "positive " + i``
*   multiple conditions ``case "-h" | "--help" => displayHelp``
*   compile-time checks for exhaustiveness

__match__ は式として値を返すところが重要です。次のように記述できます。

* 名前付きパラメータ ``case i: Int => "Int " + i``
* オブジェクトの解体 ``case Some(i) => i``
* ガード節 ``case Some(i) if i > 0 => "positive " + i``
* 複数の条件式 ``case "-h" | "--help" => displayHelp``
* コンパイル時の網羅性チェック（exhaustiveness）

Pattern matching is a great feature that saves us from writing stacks of if-then-else branches. It reduces the amount of code while focusing on the relevant parts.

パターンマッチングは if-then-else の条件分岐を無駄に積み重ねるのを減らしてくれる素敵な機能です。
コード量を減らすことで、重要な部分に注力できるからです。

[reftext="The Basics of Match for Java"]
==== Java におけるパターンマッチの基本

Vavr provides a match API that is close to Scala's match. It is enabled by adding the following import to our application:

Vavr は Scala の match によく似た match API を提供します。
次のような import 文を追加するだけで利用できるようになります。

[source,java]
----
import static io.vavr.API.*;
----

Having the static methods __Match__, __Case__ and the __atomic patterns__

*   ``$()`` - wildcard pattern
*   ``$(value)`` - equals pattern
*   ``$(predicate)`` - conditional pattern

そうすると __Match__ や __Case__ といった静的メソッドや、次のような ___atomic パターン__ が使えるようになります。

* ``$()`` - ワイルドカードパターン
* ``$(value)`` - 等値パターン
* ``$(predicate)`` - 条件式パターン

in scope, the initial Scala example can be expressed like this:

前に説明した Scala のコード例は次のように記述できます。

[source,java]
----
String s = Match(i).of(  
    Case($(1), "one"),
    Case($(2), "two"),
    Case($(), "?")
);
----

⚡ We use uniform upper-case method names because 'case' is a keyword in Java. This makes the API special.

⚡ Java では 'case' が予約語になっているため、メソッド名は大文字で始める形式に統一しています。APIとして分かりやすくなっていると思います。

[reftext="Exhaustiveness"]
===== 網羅性チェック

The last wildcard pattern ``$()`` saves us from a MatchError which is thrown if no case matches.

ワイルドカードパターン ``$()`` を使う限り、マッチしなかったときに MatchError を送出しないようになります。

Because we can't perform exhaustiveness checks like the Scala compiler, we provide the possibility to return an optional result:

Scala コンパイラのように網羅性をチェックしないので、Option を返す可能性を表現するようにしています。

[source,java]
----
Option<String> s = Match(i).option(  
    Case($(0), "zero")
);
----

[reftext="Syntactic Sugar"]
===== 糖衣構文

As already shown, ``Case`` allows to match conditional patterns.

``Case`` を使うと条件式パターンにマッチさせることができます。

[source,java]
----
Case($(predicate), ...)
----

Vavr offers a set of default predicates.

Vavr の定義済み述語式を使うには次のような import 文を追加します。

[source,java]
----
import static io.vavr.Predicates.*;
----

These can be used to express the initial Scala example as follows:

Vavr の定義済み述語式を使うと、最初の Scala のコード例は次のように記述できます。

[source,java]
----
String s = Match(i).of(  
    Case($(is(1)), "one"),
    Case($(is(2)), "two"),
    Case($(), "?")
);
----

**複数の条件**

We use the ``isIn`` predicate to check multiple conditions:

``isIn`` 述語式は複数の条件をチェックできます。

[source,java]
----
Case($(isIn("-h", "--help")), ...)
----

**副作用を引き起こす**

Match acts like an expression, it results in a value. In order to perform side-effects we need to use the helper function ``run`` which returns ``Void``:

Match は式なので値を返します。
副作用を引き起こすには、``Void`` を返すヘルパー関数 ``run`` を使わなければなりません。

[source,java]
----
Match(arg).of(  
    Case($(isIn("-h", "--help")), o -> run(this::displayHelp)),
    Case($(isIn("-v", "--version")), o -> run(this::displayVersion)),
    Case($(), o -> run(() -> {
        throw new IllegalArgumentException(arg);
    }))
);
----

⚡ ``run`` is used to get around ambiguities and because ``void`` isn't a valid return value in Java.

⚡ ``run`` を使うのは曖昧性を解消するためです。なぜなら、Java では ``void`` が正しい返り値の型ではないからです。

*Caution:* ``run`` must not be used as direct return value, i.e. outside of a lambda body:

*注意点：* ラムダ式の外側で、直接値を返すために ``run`` を使ってはいけません。

[source,java]
----
// Wrong!
Case($(isIn("-h", "--help")), run(this::displayHelp))
----

Otherwise the Cases will be eagerly evaluated __before__ the patterns are matched, which breaks the whole Match expression. Instead we use it within a lambda body:

Case の評価は貪欲評価です。
つまりパターンを __マッチさせる前__ に評価します。
その結果、マッチ式全体が壊れてしまう場合もあります。
そういうときはラムダ式の内側で ``run`` を使います。

[source,java]
----
// Ok
Case($(isIn("-h", "--help")), o -> run(this::displayHelp))
----

As we can see, ``run`` is error prone if not used right. Be careful. We consider deprecating it in a future release and maybe we will also provide a better API for performing side-effects.

ここまでに見てきた通り、 ``run`` は間違った使い方をしやすい機能です。
将来のリリースでは廃止して、副作用を引き起こすためのより適切な API を提供できないか検討するつもりです。

[reftext="Named Parameters"]
===== 名前付きパラメータ

Vavr leverages lambdas to provide named parameters for matched values.

Vavr はパターンマッチングで名前付きパラメータを実現するため、ラムダ式を利用しています。

[source,java]
----
Number plusOne = Match(obj).of(  
    Case($(instanceOf(Integer.class)), i -> i + 1),
    Case($(instanceOf(Double.class)), d -> d + 1),
    Case($(), o -> { throw new NumberFormatException(); })
);
----

So far we directly matched values using atomic patterns. If an atomic pattern matches, the right type of the matched object is inferred from the context of the pattern.

ある程度の複雑さになるまでは atomic パターンで直接値を記述できます。
atomic パターンがマッチすれば、パターンのコンテキストから適切な型のマッチオブジェクトを推論します。

Next, we will take a look at recursive patterns that are able to match object graphs of (theoretically) arbitrary depth.

次は、（理論的には）任意の深さのオブジェクトグラフにマッチできる再帰的なパターンについて説明します。

[reftext="Object Decomposition"]
===== オブジェクトの解体

In Java we use constructors to instantiate classes. We understand __object decomposition__ as destruction of objects into their parts.

Java ではコンストラクタでクラスのインスタンスを作成します。
__オブジェクトの解体__ とは、オブジェクトを複数の部品へ分解するということです。

While a constructor is a __function__ which is __applied__ to arguments and returns a new instance, a deconstructor is a function which takes an instance and returns the parts. We say an object is __unapplied__.

複数の引数を __適用し__ 新しいインスタンスを返す __関数__ がコンストラクタだとすると、デコンストラクタはインスタンスを引数として、複数の値を返す関数だと考えられます。
これを、オブジェクトを __逆適用した（unapplied）__ と呼びます。

Object destruction is not necessarily a unique operation. For example, a LocalDate can be decomposed to

*   the year, month and day components
*   the long value representing the epoch milliseconds of the corresponding Instant
*   etc.

オブジェクトの解体は必ずしも単独の操作で実現しなければならないわけではありません。
例えば、LocalDate は次のように分解できるでしょう。

* 年、月、日、それぞれのコンポーネント
* インスタントに対応する long のエポックミリ秒
* それ以外

[reftext="Patterns"]
==== さまざまなパターン

In Vavr we use patterns to define how an instance of a specific type is deconstructed. These patterns can be used in conjunction with the Match API.

Vavr では特定の型のインスタンスをどのように解体するのか説明するパターンを定義します。
これらのパターンは Match API と組み合わせて使用できます。

[reftext="Predefined Patterns"]
===== 定義済みのパターン

For many Vavr types there already exist match patterns. They are imported via

Vavr のほとんどの型には定義済みのパターンが存在します。
次のような import 文を追加すれば使用できるようになります。

[source,java]
----
import static io.vavr.Patterns.*;
----

For example we are now able to match the result of a Try:

例えば Try の結果は次のようにマッチできます。

[source,java]
----
Match(_try).of(  
    Case($Success($()), value -> ...),
    Case($Failure($()), x -> ...)
);
----

⚡ A first prototype of Vavr's Match API allowed to extract a user-defined selection of objects from a match pattern. Without proper compiler support this isn't practicable because the number of generated methods exploded exponentially. The current API makes the compromise that all patterns are matched but only the root patterns are __decomposed__.
⚡ Vavr の最初のプロトタイプに含まれる Match API では、ユーザーの定義したフィールドを抽出できるのはパターンにマッチしたオブジェクトからだけでした。生成するメソッドが指数関数的に増加してしまうため、適切なコンパイラの支援がなければ実用的ではありませんでした。現在の API はその辺を妥協して全てのパターンにマッチはするけど親の（root の）パターンだけを __解体__ するようになっています。

[source,java]
----
Match(_try).of(  
    Case($Success(Tuple2($("a"), $())), tuple2 -> ...),
    Case($Failure($(instanceOf(Error.class))), error -> ...)
);
----

Here the root patterns are Success and Failure. They are decomposed to Tuple2 and Error, having the correct generic types.

この場合親の（root の）パターンは `Success` と `Failure` です。
それぞれより一般的な型の `Tuple2` と `Error` へ分解できます。

// ⚡ Deeply nested types are inferred according to the Match argument and __not__ according to the matched patterns.
⚡ ネストした型を深くまで推論するのはマッチされた引数であって、マッチしたパターン __ではありません__ 。

[reftext="User-Defined Patterns"]
===== ユーザー定義パターン

It is essential to be able to unapply arbitrary objects, including instances of final classes. Vavr does this in a declarative style by providing the compile time annotations ``@Patterns`` and ``@Unapply``.

たとえそれが final クラスのオブジェクトであっても、オブジェクトを逆適用できるようにするのは必要不可欠です。
Vavr では、コンパイル時に処理するアノテーション ``@Patters`` と ``@Unapply`` で宣言的に記述できるようにしました。

To enable the annotation processor the artifact http://search.maven.org/#search%7Cga%7C1%7Cvavr-match[vavr-match] needs to be added as project dependency.

アノテーションプロセッサを有効化するには https://mvnrepository.com/artifact/io.vavr/vavr-match[vavr-match] をプロジェクトの依存ライブラリに追加しなければなりません。

// ⚡ Note: Of course the patterns can be implemented directly without using the code generator. For more information take a look at the generated source.
⚡ 注意点：当然ですが、パターンはコードジェネレータを使わなくても直接実装できます。詳しい内容については自動生成されたソースコードを参照してくｄさい。

[source,java]
----
import io.vavr.match.annotation.*;

@Patterns
class My {

    @Unapply
    static <T> Tuple1<T> Optional(java.util.Optional<T> optional) {
        return Tuple.of(optional.orElse(null));
    }
}
----

The annotation processor places a file MyPatterns in the same package (by default in target/generated-sources). Inner classes are also supported. Special case: if the class name is $, the generated class name is just Patterns, without prefix.

アノテーションプロセッサは同じパッケージにファイル `MyPatterns` を作成します（デフォルトの作成位置は target/generated-sources です）。
内部クラスにも対応しています。
ただし、クラス名が `$` の場合、自動生成されたクラス名はただの `Patterns` になります。前置詞は付きません。

[reftext="Guards"]
===== ガード節

Now we are able to match Optionals using __guards__.

Option に対するマッチを __ガード節__ として記述できます。

[source,java]
----
Match(optional).of(  
    Case($Optional($(v -> v != null)), "defined"),
    Case($Optional($(v -> v == null)), "empty")
);
----

The predicates could be simplified by implementing ``isNull`` and ``isNotNull``.

これらの述語式は ``isNull`` や ``isNotNull`` を実装すれば簡潔にできます。

⚡ And yes, extracting null is weird. Instead of using Java's Optional give Vavr's Option a try!
⚡ もちろん、null の抽出にも結びついています。Java の Optional ではなく Vavr の Option を試してみましょう。

[source,java]
----
Match(option).of(  
    Case($Some($()), "defined"),
    Case($None(), "empty")
);
----
